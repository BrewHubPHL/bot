<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BrewBot @ BrewHubPHL</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(to bottom, #f8f4f0, #e8e0d4); margin: 0; height: 100vh; display: flex; flex-direction: column; color: #3c2f2f; }
        header { background: #3c2f2f; color: #fff; padding: 30px 20px; text-align: center; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        #logo { max-width: 320px; width: 85%; height: auto; margin: 0 auto 15px; display: block; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2)); }
        header p { margin: 0; font-size: 1.1em; opacity: 0.95; }
        #chat-container { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 18px; }
        .message { max-width: 80%; padding: 16px 20px; border-radius: 20px; line-height: 1.5; font-size: 1.1em; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .bot { background: #e0d6c9; align-self: flex-start; border-bottom-left-radius: 6px; }
        .user { background: #d4b59e; color: #fff; align-self: flex-end; border-bottom-right-radius: 6px; }
        #input-area { display: flex; padding: 15px 20px; background: #fff; border-top: 1px solid #ddd; align-items: center; gap: 12px; box-shadow: 0 -4px 12px rgba(0,0,0,0.1); }
        input { flex: 1; padding: 16px 20px; border: 1px solid #ccc; border-radius: 30px; font-size: 1.1em; background: #f8f4f0; }
        button { padding: 0 24px; background: #6b4f4f; color: white; border: none; border-radius: 30px; cursor: pointer; font-weight: bold; height: 56px; min-width: 90px; font-size: 1.1em; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: all 0.2s; }
        button:hover { background: #8b6f6f; transform: translateY(-2px); }
        button:disabled { background: #aaa; cursor: not-allowed; transform: none; }
        #mic-btn { background: #6b4f4f; width: 60px; height: 60px; border-radius: 50%; font-size: 1.8em; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
        #mic-btn.recording { background: #d32f2f; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(211,47,47,0.7); } 70% { box-shadow: 0 0 0 12px rgba(211,47,47,0); } 100% { box-shadow: 0 0 0 0 rgba(211,47,47,0); } }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            body { font-size: 16px; } /* Prevent zoom on iOS */
            header { padding: 20px 15px; }
            #logo { max-width: 280px; width: 90%; }
            header p { font-size: 1em; }
            #chat-container { padding: 15px; gap: 15px; }
            .message { max-width: 85%; padding: 14px 18px; font-size: 1em; }
            #input-area { padding: 12px 15px; gap: 8px; }
            input { padding: 14px 18px; font-size: 1em; }
            button { height: 50px; min-width: 80px; font-size: 1em; padding: 0 20px; }
            #mic-btn { width: 50px; height: 50px; font-size: 1.5em; }
            #waitlist-content { padding: 25px; max-width: 90%; }
            #waitlist-form input { padding: 14px; font-size: 1em; }
        }

        @media (max-width: 480px) {
            header { padding: 15px 10px; }
            #logo { max-width: 250px; width: 95%; }
            header p { font-size: 0.9em; }
            #chat-container { padding: 10px; }
            .message { max-width: 90%; padding: 12px 16px; font-size: 0.95em; }
            #input-area { padding: 10px 12px; flex-wrap: wrap; justify-content: center; }
            input { flex: 1 1 100%; margin-bottom: 8px; }
            button { flex: 0 0 auto; }
            #mic-btn { order: -1; } /* Mic button first on mobile */
            #send-btn { flex: 1; }
        }

        /* Touch-friendly interactions */
        @media (hover: none) and (pointer: coarse) {
            button:hover { transform: none; background: #8b6f6f; }
            .waitlist-btn:hover { background: #8b6f6f; }
        }

        /* Waitlist Modal */
        #waitlist-modal { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); justify-content: center; align-items: center; z-index: 1000; }
        #waitlist-content { background: white; padding: 30px; border-radius: 15px; max-width: 400px; width: 90%; text-align: center; position: relative; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        #close-modal { position: absolute; top: 10px; right: 15px; font-size: 1.8em; cursor: pointer; color: #aaa; }
        #waitlist-form { display: flex; flex-direction: column; gap: 15px; margin-top: 20px; }
        #waitlist-form input { padding: 15px; border: 1px solid #ccc; border-radius: 30px; font-size: 1.1em; }
        #waitlist-form button { background: #6b4f4f; padding: 15px; font-size: 1.2em; }
        #success-msg { color: green; font-weight: bold; margin-top: 15px; display: none; }
        .waitlist-btn { background: #6b4f4f; color: white; border: none; padding: 10px 20px; border-radius: 30px; cursor: pointer; margin-top: 10px; font-size: 1em; }
        .waitlist-btn:hover { background: #8b6f6f; }
    </style>
</head>
<body>
    <!-- Hidden dummy form for Netlify - REMOVED, now using mailto -->

    <header>
        <img src="logo.png" alt="BrewHubPHL Logo" id="logo">
        <p>Philly's upcoming coffee + parcel hub ‚Äî talk or type for personalized drinks!</p>
    </header>
    <div id="chat-container">
        <div class="message bot">
            Hey! Welcome to BrewHubPHL (opening soon in Point Breeze, Philly).<br>
            Tell me about the weather, your mood, cravings... (type or tap the mic to speak). I'll suggest the perfect drink and read it aloud.
        </div>
    </div>
    <div id="input-area">
        <input type="text" id="user-input" placeholder="Type or tap mic to speak..." autocomplete="off">
        <button id="mic-btn" title="Hold to speak">üé§</button>
        <button id="send-btn">Send</button>        <button id="clear-btn" title="Clear chat">üóëÔ∏è</button>    </div>

    <!-- Waitlist Modal -->
    <div id="waitlist-modal">
        <div id="waitlist-content">
            <span id="close-modal">&times;</span>
            <h2>Join the BrewHubPHL Waitlist</h2>
            <p>Get opening alerts, exclusive perks, and maybe a free drink on us.</p>
            <form id="waitlist-form" action="mailto:info@brewhubphl.com" method="POST" enctype="text/plain">
                <input type="text" name="name" placeholder="Your Name" required />
                <input type="email" name="email" placeholder="Your Email" required />
                <input type="hidden" name="subject" value="BrewHubPHL Waitlist Signup" />
                <input type="hidden" name="body" value="New waitlist signup from BrewBot:" />
                <button type="submit">Sign Up</button>
            </form>
            <div id="success-msg">Thanks! You're on the list ‚Äî we'll be in touch soon.</div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded - BrewBot ready');

            const MODEL = 'grok-3-mini';

            const VOICE_ID = '21m00Tcm4TlvDq8ikWAM'; // Rachel

            const SYSTEM_PROMPT = `You are BrewBot, the friendly AI barista at BrewHubPHL, a new independent coffee shop + parcel hub opening soon in Point Breeze, Philadelphia.

Our menu includes:
- Sizes: Small (12oz), Medium (16oz +$0.75), Large (20oz +$1.50)
- Milk: Whole/Skim (free), Oat/Almond (+$0.75), Soy (+$0.50)
- Extra Espresso Shot: +$1.00
- Syrups/Flavors: Vanilla, Caramel, Hazelnut, Mocha, Lavender, Seasonal (+$0.75 each)
- Hot or Iced: Free switch
- Decaf: Free

Drinks:
- Espresso Classics: Espresso ($3.50 single/$4.50 double), Macchiato ($4.25), Cortado ($4.50), Cappuccino ($4.75), Flat White ($5.00), Americano ($4.00), Latte ($5.00), Mocha ($5.50)
- Brewed: House Drip ($3.50), Pour Over ($5.50 single-origin), Cold Brew ($5.00)
- Tea & More: Chai Latte ($5.00), Matcha Latte ($5.50), London Fog ($5.00), Hot Chocolate ($4.75), Loose Leaf Tea ($4.00)
- Seasonal (Winter): Maple Spice Latte ($5.75), Peppermint Mocha ($5.75)

Rules:
1. Be very concise: 3-5 sentences max per response.
2. Use short bullet points for drink suggestions and customizations.
3. Keep explanations brief.
4. Guide customizations naturally but quickly.
5. Confirm order with price in one short line.
6. If the user completes an order, say "Saved as your favorite for opening day!" and optionally suggest joining the waitlist.
7. Be friendly, Philly-local vibe.
8. Do not use any emojis.
Never suggest off-menu items or imply pickup/text notifications (we're not open yet).
Current date: January 2026 (winter season).`;

            let conversation = [{ role: "system", content: SYSTEM_PROMPT }];

            const chatContainer = document.getElementById('chat-container');
            const userInput = document.getElementById('user-input');
            const sendBtn = document.getElementById('send-btn');
            const clearBtn = document.getElementById('clear-btn');
            const micBtn = document.getElementById('mic-btn');

            // Waitlist Modal Elements
            const modal = document.getElementById('waitlist-modal');
            const closeModal = document.getElementById('close-modal');
            const waitlistForm = document.getElementById('waitlist-form');
            const successMsg = document.getElementById('success-msg');

            closeModal.onclick = () => { modal.style.display = 'none'; successMsg.style.display = 'none'; };
            window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

            // Remove form submission handler - mailto will handle it
            // waitlistForm.addEventListener('submit', async (e) => {
            //     e.preventDefault();
            //     const formData = new FormData(waitlistForm);
            //     try {
            //         const response = await fetch('/', { method: 'POST', body: formData });
            //         if (response.ok) {
            //             successMsg.style.display = 'block';
            //             waitlistForm.reset();
            //             setTimeout(() => { modal.style.display = 'none'; successMsg.style.display = 'none'; }, 3000);
            //         } else {
            //             alert('Submission failed ‚Äî try again.');
            //         }
            //     } catch (err) {
            //         alert('Local test: Form logged to console.');
            //         console.log('Form data:', Object.fromEntries(formData));
            //     }
            // });

            function addMessage(text, sender) {
                const div = document.createElement('div');
                div.className = `message ${sender}`;
                div.innerHTML = text.replace(/\n/g, '<br>');
                chatContainer.appendChild(div);
                div.scrollIntoView({ behavior: 'smooth' });
                return div;
            }

            async function playWithElevenLabs(text) {
                if (!text) return;
                try {
                    console.log('Requesting TTS for:', text);
                    const response = await fetch('/.netlify/functions/elevenlabs-tts', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ text })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('TTS proxy error:', response.status, errorText);
                        throw new Error(`TTS proxy error ${response.status}: ${errorText}`);
                    }

                    // Get the base64 encoded audio data
                    const base64Audio = await response.text();
                    console.log('Received base64 audio, length:', base64Audio.length);

                    // Create audio element with data URL
                    const audioDataUrl = `data:audio/mpeg;base64,${base64Audio}`;
                    const audio = new Audio(audioDataUrl);

                    // Add event listeners for debugging
                    audio.addEventListener('loadstart', () => console.log('Audio loading started'));
                    audio.addEventListener('canplay', () => console.log('Audio can play'));
                    audio.addEventListener('error', (e) => console.error('Audio error:', e));

                    // Play the audio
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Audio playing successfully');
                        }).catch(error => {
                            console.error('Audio play failed:', error);
                            throw error;
                        });
                    }

                } catch (err) {
                    console.error('TTS error:', err);
                    // Fallback to browser TTS
                    if ('speechSynthesis' in window) {
                        console.log('Falling back to browser TTS');
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = 0.9;
                        utterance.pitch = 1.1;
                        speechSynthesis.speak(utterance);
                    }
                }
            }

            let recognition = null;
            let isListening = false;
            let silenceTimer = null;
            let finalTranscript = '';

            // Initialize speech recognition with auto-silence detection
            if ('SpeechRecognition' in window || 'webkitSpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false; // Single utterance mode
                recognition.interimResults = false; // Only final results
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;

                recognition.onstart = () => {
                    console.log('Voice recognition started');
                    isListening = true;
                    finalTranscript = '';
                    micBtn.classList.add('recording');
                    userInput.placeholder = 'Listening... (speak now)';
                    userInput.value = '';
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    console.log('Voice result:', transcript);
                    userInput.value = transcript;
                    userInput.focus();

                    // Auto-send after a brief delay to show the result
                    setTimeout(() => {
                        if (userInput.value.trim()) {
                            console.log('Auto-sending voice message:', userInput.value.trim());
                            sendMessage();
                        }
                    }, 500);
                };

                recognition.onend = () => {
                    console.log('Voice recognition ended');
                    isListening = false;
                    micBtn.classList.remove('recording');
                    userInput.placeholder = 'Type or tap mic to speak...';
                };

                recognition.onerror = (event) => {
                    console.error('Voice recognition error:', event.error);
                    isListening = false;
                    micBtn.classList.remove('recording');
                    userInput.placeholder = 'Type or tap mic to speak...';

                    // Show user-friendly error messages
                    let errorMsg = 'Voice not available';
                    switch(event.error) {
                        case 'not-allowed':
                            errorMsg = 'Microphone permission denied';
                            break;
                        case 'no-speech':
                            errorMsg = 'No speech detected - try speaking louder';
                            break;
                        case 'network':
                            errorMsg = 'Network error - try again';
                            break;
                        case 'aborted':
                            errorMsg = 'Voice input cancelled';
                            break;
                    }

                    // Temporary visual feedback
                    const originalText = micBtn.textContent;
                    micBtn.textContent = '‚ùå';
                    setTimeout(() => {
                        micBtn.textContent = originalText;
                    }, 2000);
                };

            } else {
                console.warn('Speech recognition not supported');
                micBtn.style.display = 'none';
            }

            // Improved mobile voice button handling
            if (recognition) {
                const startListening = async () => {
                    if (isListening) return;

                    try {
                        // Request microphone permission if needed
                        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                            await navigator.mediaDevices.getUserMedia({ audio: true });
                        }

                        recognition.start();
                    } catch (err) {
                        console.error('Microphone access error:', err);
                        alert('Microphone access is required for voice input. Please allow microphone permissions and try again.');
                    }
                };

                // Mouse events (desktop) - single click to start
                micBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    startListening();
                });

                // Touch events (mobile) - tap to start
                micBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startListening();
                });

                // Prevent default touch behavior
                micBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                });
            }

            async function sendMessage() {
                console.log('Send triggered');
                let msg = userInput.value.trim();
                if (!msg) return;

                addMessage(msg, 'user');
                userInput.value = '';
                sendBtn.disabled = true;

                conversation.push({ role: "user", content: msg });

                const typing = addMessage('BrewBot thinking...', 'bot');
                typing.id = 'typing';

                try {
                    const res = await fetch('/.netlify/functions/grok-proxy', {
                        method: 'POST',
                        body: JSON.stringify({ messages: conversation })
                    });

                    if (!res.ok) throw new Error(`Proxy error ${res.status}`);

                    const data = await res.json();
                    let reply = data.choices[0].message.content.trim();

                    // Waitlist button when order complete
                    if (reply.toLowerCase().includes('saved as') || reply.toLowerCase().includes('opening day')) {
                        reply += '<br><br><button class="waitlist-btn" onclick="document.getElementById(\'waitlist-modal\').style.display=\'flex\'">Join the Waitlist</button>';
                    }

                    document.getElementById('typing')?.remove();
                    addMessage(reply, 'bot');
                    playWithElevenLabs(reply);

                    conversation.push({ role: "assistant", content: reply });
                } catch (err) {
                    console.error('Proxy error:', err);
                    document.getElementById('typing')?.remove();
                    addMessage('Oops ‚Äî something went wrong. Try again?', 'bot');
                } finally {
                    sendBtn.disabled = false;
                }
            }

            sendBtn.addEventListener('click', sendMessage);
            userInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            clearBtn.addEventListener('click', () => {
                if (confirm('Clear the entire chat?')) {
                    chatContainer.innerHTML = '';
                    conversation = [{ role: "system", content: SYSTEM_PROMPT }];
                    addMessage('Hey! Welcome to BrewHubPHL (opening soon in Point Breeze, Philly).<br>Tell me about the weather, your mood, cravings... (type or tap the mic to speak). I\'ll suggest the perfect drink and read it aloud.', 'bot');
                }
            });

            console.log('Event listeners attached');
        });
    </script>
</body>
</html>